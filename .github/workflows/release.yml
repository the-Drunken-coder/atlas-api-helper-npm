name: Release (npm)

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - "package/**"

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          registry-url: "https://registry.npmjs.org"
          cache: "npm"
          cache-dependency-path: package/package-lock.json

      - name: Determine version range
        id: versions
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -f package/package.json ]; then
            echo "::error::Missing package/package.json"
            exit 1
          fi

          NEW_VERSION="$(node -p "require('./package/package.json').version")"

          CUR_COMMIT="$(git rev-parse HEAD)"
          PREV_COMMIT=""
          OLD_VERSION=""

          if git rev-parse HEAD^ >/dev/null 2>&1; then
            PREV_COMMIT="$(git rev-parse HEAD^)"
            OLD_VERSION="$(git show "${PREV_COMMIT}:package/package.json" | node -e "const fs=require('fs'); const j=JSON.parse(fs.readFileSync(0,'utf8')); process.stdout.write(j.version)")"
          fi

          echo "new_version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "old_version=${OLD_VERSION}" >> "$GITHUB_OUTPUT"
          echo "cur_commit=${CUR_COMMIT}" >> "$GITHUB_OUTPUT"
          echo "prev_commit=${PREV_COMMIT}" >> "$GITHUB_OUTPUT"

          if [ -n "${OLD_VERSION}" ] && [ "${NEW_VERSION}" = "${OLD_VERSION}" ]; then
            echo "version_changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "version_changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Sync root README from package README
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f package/README.md ]; then
            echo "::error::Missing package/README.md"
            exit 1
          fi
          cp package/README.md README.md

      - name: Update CHANGELOG.md via OpenRouter
        if: steps.versions.outputs.version_changed == 'true'
        shell: bash
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          OPENROUTER_MODEL: ${{ vars.OPENROUTER_MODEL }}
          NEW_VERSION: ${{ steps.versions.outputs.new_version }}
          CUR_COMMIT: ${{ steps.versions.outputs.cur_commit }}
          PREV_COMMIT: ${{ steps.versions.outputs.prev_commit }}
        run: |
          set -euo pipefail
          if [ -z "${OPENROUTER_API_KEY:-}" ]; then
            echo "::error::Missing OPENROUTER_API_KEY secret"
            exit 1
          fi

          python3 - <<'PY'
          import json
          import os
          import subprocess
          import sys
          import textwrap
          import time
          import urllib.request
          from datetime import datetime, timezone


          def sh(*args):
              return subprocess.check_output(list(args), text=True).strip()


          def get_per_file_diffs(log_range, path_scope, total_budget=12000):
              """Get diffs with budget distributed equally across changed files."""
              try:
                  changed = sh("git", "diff", "--name-only", log_range, "--", path_scope)
              except subprocess.CalledProcessError:
                  return ""
              if not changed:
                  return ""

              files = [f for f in changed.splitlines() if f.strip()]
              if not files:
                  return ""

              file_diffs = {}
              for f in files:
                  try:
                      file_diffs[f] = sh("git", "diff", log_range, "--", f)
                  except subprocess.CalledProcessError:
                      file_diffs[f] = ""

              sorted_files = sorted(files, key=lambda f: len(file_diffs.get(f, "")))

              allocations = {}
              remaining_budget = total_budget
              remaining_files = list(sorted_files)

              for f in sorted_files:
                  share = remaining_budget // max(len(remaining_files), 1)
                  diff_len = len(file_diffs.get(f, ""))
                  if diff_len <= share:
                      allocations[f] = diff_len
                      remaining_budget -= diff_len
                  else:
                      allocations[f] = share
                      remaining_budget -= share
                  remaining_files.remove(f)

              truncated = [f for f in sorted_files if allocations[f] < len(file_diffs.get(f, ""))]
              if truncated and remaining_budget > 0:
                  extra = remaining_budget // len(truncated)
                  for f in truncated:
                      allocations[f] += extra

              parts = []
              for f in files:
                  diff = file_diffs.get(f, "")
                  if not diff:
                      continue
                  budget = allocations.get(f, 0)
                  if len(diff) <= budget:
                      parts.append(diff)
                  else:
                      t = diff[:budget]
                      last_nl = t.rfind("\n")
                      if last_nl > 0:
                          t = t[:last_nl]
                      parts.append(t + f"\n... (truncated, {len(diff) - len(t)} more chars)")

              return "\n".join(parts)


          def build_fallback(new_version, date, commits, changed_files):
              """Build fallback from actual commit info instead of generic text."""
              bullets = []
              if commits:
                  for line in commits.splitlines():
                      line = line.strip()
                      if not line:
                          continue
                      if line.startswith(("chore(sync):", "chore(release):")):
                          continue
                      bullets.append(f"- {line}")

              if not bullets and changed_files:
                  bullets.append("- Updated package source (synced from upstream monorepo)")
                  for stat_line in changed_files.splitlines():
                      stat_line = stat_line.strip()
                      if "|" in stat_line:
                          fname = stat_line.split("|")[0].strip()
                          if fname and not fname.endswith((".lock", ".json")):
                              bullets.append(f"- Modified {fname}")

              if not bullets:
                  bullets = [
                      "- Synced latest changes from upstream ATLAS monorepo",
                      f"- Version bump to {new_version}",
                  ]

              return f"## [{new_version}] - {date}\n" + "\n".join(bullets[:8])


          # ── main ──────────────────────────────────────────────────────
          new_version = os.environ["NEW_VERSION"]
          cur_commit = os.environ.get("CUR_COMMIT", "")
          prev_commit = os.environ.get("PREV_COMMIT", "")
          model = os.environ.get("OPENROUTER_MODEL") or "moonshotai/kimi-k2.5"

          log_range = f"{prev_commit}..{cur_commit}" if prev_commit else (cur_commit or "HEAD")

          diff_context = get_per_file_diffs(log_range, "package")

          try:
              commits = sh("git", "log", "--pretty=%s", log_range, "--", "package")
          except subprocess.CalledProcessError:
              commits = ""

          try:
              changed_files = sh("git", "diff", "--stat", log_range, "--", "package")
          except subprocess.CalledProcessError:
              changed_files = ""

          date = datetime.now(timezone.utc).strftime("%Y-%m-%d")

          prompt = textwrap.dedent(f"""\
          You are updating a Keep-a-Changelog style CHANGELOG.md for an npm package.

          Task:
          - Produce ONE markdown section for version {new_version} dated {date}.
          - Output MUST start exactly with: ## [{new_version}] - {date}
          - Then include a short bullet list (3-8 bullets) summarizing user-visible changes.
          - Focus on what changed functionally: new features, bug fixes, API changes, behavioral changes.
          - If changes are mostly internal/refactor, summarize what was refactored and why it matters.
          - Do NOT use generic filler like "internal updates and maintenance" — be specific.
          - Do not include code blocks, markdown fences, links, or extra commentary.

          Context:
          - This repo mirrors source code from another monorepo into the `package/` directory.

          Commit subjects:
          {commits}

          File change summary:
          {changed_files}

          Code diffs (per-file, may be truncated):
          {diff_context}
          """)

          body = {
              "model": model,
              "messages": [
                  {"role": "system", "content": "You write concise, accurate changelog entries based on code diffs. You never use generic filler text."},
                  {"role": "user", "content": prompt},
              ],
              "temperature": 0.2,
              "max_tokens": 16000,
          }

          req = urllib.request.Request(
              "https://openrouter.ai/api/v1/chat/completions",
              data=json.dumps(body).encode("utf-8"),
              headers={
                  "Authorization": f"Bearer {os.environ['OPENROUTER_API_KEY']}",
                  "Content-Type": "application/json",
                  "HTTP-Referer": "https://github.com/the-Drunken-coder/atlas-api-helper-npm",
                  "X-Title": "atlas-api-helper-npm changelog bot",
              },
              method="POST",
          )

          content = ""
          last_error = None
          for attempt in range(3):
              try:
                  with urllib.request.urlopen(req, timeout=90) as resp:
                      data = json.loads(resp.read().decode("utf-8"))

                  if isinstance(data, dict) and data.get("error"):
                      last_error = data["error"]
                      print(f"::warning::OpenRouter attempt {attempt+1} returned error: {last_error}", file=sys.stderr)
                      raise RuntimeError(str(last_error))

                  raw = (data.get("choices") or [{}])[0].get("message", {}).get("content", "").strip()
                  print(f"::notice::LLM response preview (attempt {attempt+1}): {raw[:200]}", file=sys.stderr)

                  if raw.startswith("```"):
                      lines = raw.splitlines()
                      if lines and lines[0].startswith("```"):
                          lines = lines[1:]
                      if lines and lines[-1].startswith("```"):
                          lines = lines[:-1]
                      raw = "\n".join(lines).strip()

                  if raw.startswith(f"## [{new_version}] - {date}"):
                      content = raw
                      break

                  last_error = f"Response did not start with expected heading. Got: {raw[:150]}"
                  print(f"::warning::OpenRouter attempt {attempt+1}: {last_error}", file=sys.stderr)
              except Exception as e:
                  last_error = repr(e)
                  print(f"::warning::OpenRouter attempt {attempt+1} failed: {last_error}", file=sys.stderr)

              time.sleep(2 * (attempt + 1))

          if not content:
              print(f"::warning::All LLM attempts failed. Last error: {last_error}", file=sys.stderr)
              print("::warning::Using diff-based fallback for changelog entry.", file=sys.stderr)
              content = build_fallback(new_version, date, commits, changed_files)

          changelog_path = "CHANGELOG.md"
          try:
              existing = open(changelog_path, "r", encoding="utf-8").read()
          except FileNotFoundError:
              existing = "# Changelog\n\n"

          if f"## [{new_version}] -" in existing:
              sys.exit(0)

          lines = existing.splitlines(True)
          insert_at = 0
          for i, line in enumerate(lines):
              if line.strip() == "# Changelog":
                  insert_at = i + 1
                  break
          while insert_at < len(lines) and lines[insert_at].strip() != "":
              insert_at += 1
          if insert_at < len(lines):
              insert_at += 1

          snippet = content.rstrip() + "\n\n"
          new_lines = lines[:insert_at] + [snippet] + lines[insert_at:]

          with open(changelog_path, "w", encoding="utf-8", newline="\n") as f:
              f.write("".join(new_lines))
          PY

      - name: Commit README + CHANGELOG (if changed)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add README.md CHANGELOG.md
          if git diff --cached --quiet; then
            echo "No README/CHANGELOG changes to commit."
            exit 0
          fi

          VERSION="${{ steps.versions.outputs.new_version }}"
          git commit -m "chore(release): update docs + changelog for v${VERSION}"
          git push

      - name: Install dependencies
        if: steps.versions.outputs.version_changed == 'true'
        working-directory: package
        run: npm ci

      - name: Test
        if: steps.versions.outputs.version_changed == 'true'
        working-directory: package
        run: npm test

      - name: Build
        if: steps.versions.outputs.version_changed == 'true'
        working-directory: package
        run: npm run build

      - name: Publish to npm (if not already published)
        if: steps.versions.outputs.version_changed == 'true'
        working-directory: package
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${NODE_AUTH_TOKEN:-}" ]; then
            echo "::error::Missing NPM_TOKEN secret"
            exit 1
          fi

          PKG_NAME="$(node -p "require('./package.json').name")"
          VERSION="$(node -p "require('./package.json').version")"

          if npm view "${PKG_NAME}@${VERSION}" version >/dev/null 2>&1; then
            echo "Already published: ${PKG_NAME}@${VERSION}"
            exit 0
          fi

          npm publish --access public
